# -*- coding: utf-8 -*-
"""Style_Transfer_Solution Demo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XcgMBC5Yy7nRwoYC8ZN9h-i77W329367
"""

# Commented out IPython magic to ensure Python compatibility.
# import resources
# %matplotlib inline

from PIL import Image
from io import BytesIO
import matplotlib.pyplot as plt
import numpy as np

import torch
import torch.optim as optim
import requests
from torchvision import transforms, models

"""# **Load in Resnet34 (features)**
Resnet34 is split into two portions:

*   resnet34.features, which are all the convolutional and pooling layers
*   resnet34.classifier, which are the three linear, classifier layers at the end

We only need the features portion, which we're going to load in and "freeze" the weights of, below.
"""

# get the "features" portion of resnet (we will not need the "classifier" portion)
resnet = models.resnet34(pretrained=True)

# freeze all resnet parameters since we're only optimizing the target image
for param in resnet.parameters():
    param.requires_grad_(False)

# move the model to GPU, if available
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
resnet.to(device)

"""# **Load in Content and Style Images**
You can load in any images you want! Below, we've provided a helper function for loading in any type and size of image. The load_image function also converts images to normalized Tensors.

Additionally, it will be easier to have smaller images and to squish the content and style images so that they are of the same size.
"""

def load_image(img_path, max_size=400, shape=None):
    ''' Load in and transform an image, making sure the image
       is <= 400 pixels in the x-y dims.'''
    if "http" in img_path:
        response = requests.get(img_path)
        image = Image.open(BytesIO(response.content)).convert('RGB')
    else:
        image = Image.open(img_path).convert('RGB')

    # large images will slow down processing
    if max(image.size) > max_size:
        size = max_size
    else:
        size = max(image.size)

    if shape is not None:
        size = shape

    in_transform = transforms.Compose([
                        transforms.Resize(size),
                        transforms.ToTensor(),
                        transforms.Normalize((0.485, 0.456, 0.406),
                                             (0.229, 0.224, 0.225))])

    # discard the transparent, alpha channel (that's the :3) and add the batch dimension
    image = in_transform(image)[:3,:,:].unsqueeze(0)

    return image

# load in content and style image
content = load_image('content.jpg').to(device)
# Resize style to match content, makes code easier
style = load_image('style.jpeg', shape=content.shape[-2:]).to(device)

# helper function for un-normalizing an image
# and converting it from a Tensor image to a NumPy image for display
def im_convert(tensor):
    """ Display a tensor as an image. """

    image = tensor.to("cpu").clone().detach()
    image = image.numpy().squeeze()
    image = image.transpose(1,2,0)
    image = image * np.array((0.229, 0.224, 0.225)) + np.array((0.485, 0.456, 0.406))
    image = image.clip(0, 1)

    return image

# display the images
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(20, 10))
# content and style ims side-by-side
ax1.imshow(im_convert(content))
ax2.imshow(im_convert(style))

def get_features(image, model, layers=None):
    """ Run an image forward through a model and get the features for
        a set of layers. Default layers are for VGGNet matching Gatys et al (2016)
    """

    ## TODO: Complete mapping layer names of PyTorch's VGGNet to names from the paper
    ## Need the layers for the content and style representations of an image
    if layers is None:
        layers = {'0': 'conv1_1',
                  '5': 'conv2_1',
                  '10': 'conv3_1',
                  '19': 'conv4_1',
                  '21': 'conv4_2',  ## content representation
                  '28': 'conv5_1'}

    features = {}
    x = image
    # model._modules is a dictionary holding each module in the model
    layer = model._modules.items()
    for name, layer in model._modules.items():
        x = layer(x)
        if name in layers:
            features[layers[name]] = x

    return features

from torchvision.models.feature_extraction import create_feature_extractor
def get_features(image,model,layers=None):

    return_nodes = {
        # node_name: user-specified key for output dict
        'conv1':'conv1_1',
        'layer1.2.conv2': 'conv2_1',
        'layer2.3.conv2': 'conv3_1',
        'layer3.0.conv2': 'conv4_1',
        'layer3.5.conv2': 'conv4_2',
        'layer4.0.conv2':'conv5_1'
    }
    b = create_feature_extractor(model, return_nodes=return_nodes)
    feat = b(image)
    return feat

"""
# **Gram Matrix**
The output of every convolutional layer is a Tensor with dimensions associated with the batch_size, a depth, d, and some height and width (h, w). It is possible to calculate the Gram matrix of a convolutional layer as follows:


*   Get the depth, height, and width of a tensor using batch_size, d, h, w = tensor.size
*   Reshape that tensor so that the spatial dimensions are flattened

*   Calculate the gram matrix by multiplying the reshaped tensor by it's transpose

Note: You can multiply two matrices using torch.mm(matrix1, matrix2)."""

def gram_matrix(tensor):
    """ Calculate the Gram Matrix of a given tensor
        Gram Matrix: https://en.wikipedia.org/wiki/Gramian_matrix
    """

    # get the batch_size, depth, height, and width of the Tensor
    b, d, h, w = tensor.size()

    # reshape so we're multiplying the features for each channel
    tensor = tensor.view(b * d, h * w)

    # calculate the gram matrix
    gram = torch.mm(tensor, tensor.t())

    return gram

# get content and style features only once before training
content_features = get_features(content, resnet)
style_features = get_features(style, resnet)

# calculate the gram matrices for each layer of our style representation
style_grams = {layer: gram_matrix(style_features[layer]) for layer in style_features}

# create a third "target" image and prep it for change
# it is a good idea to start off with the target as a copy of our *content* image
# then iteratively change its style
target = content.clone().requires_grad_(True).to(device)

"""# **Loss and Weights**

**Individual Layer Style Weights**

Below, you are given the option to weigh the style representation at each relevant layer. It's suggested that you use a range between 0 and 1 to weigh these layers. By weighting earlier layers (conv1_1 and conv2_1) more, you can expect to get larger style artifacts in your resulting target image. Should you choose to weigh later layers, you'll get more emphasis on smaller features. This is because each layer is a different size and together they create a multi-scale representation.

**Content and Style Weight**

Just like in the paper, we define an alpha (content_weight) and a beta (style_weight). This ratio will affect how stylized your final image is. To achieve the desired ratio, leave the content_weight = 1 and set the style_weight to 1.
"""

# weights for each style layer
# weighting earlier layers more will result in *larger* style artifacts
# notice we are excluding `conv4_2` our content representation
style_weights = {'conv1_1': 1.,
                 'conv2_1': 0.75,
                 'conv3_1': 0.2,
                 'conv4_1': 0.2,
                 'conv5_1': 0.2}

content_weight = 1  # alpha
style_weight = 1e8  # beta

"""# **Update the Target & Calculate Losses**

You'll decide on a number of steps for which to update your image. This is similar to the training loop that you've seen before. However, we are only changing our target image and nothing else about VGG19 or any other image. Therefore, the number of steps is really up to you to set! I recommend using at least 2000 steps to achieve good results. But, you may want to start out with fewer steps if you are just testing out different weight values or experimenting with different images.

Inside each iteration, you'll calculate the content and style losses and update your target image accordingly.

**Content loss**

The content loss will be the mean squared difference between the target and content features at layer conv4_2. This can be calculated as follows:

Content_loss = torch.mean((target_features['conv4_2'] - content_features['conv4_2'])**2)

**Style loss **

The style loss is calculated in a similar way, only you have to iterate through a number of layers, specified by name in our dictionary style_weights.

You'll calculate the gram matrix for the target image, target_gram and style image style_gram at each of these layers and compare those gram matrices, calculating the layer_style_loss. Later, you'll see that this value is normalized by the size of the layer.

**Total loss**

Finally, you'll create the total loss by adding up the style and content losses and weighting them with your specified alpha and beta!

Intermittently, we'll print out this loss; don't be alarmed if the loss is very large. It takes some time for an image's style to change and you should focus on the appearance of your target image rather than any loss value. Even so, you should see that after a certain number of iterations, this loss should decrease.
"""

# for displaying the target image, intermittently
show_every = 400

# iteration hyperparameters
optimizer = optim.Adam([target], lr=0.003)
steps = 2000  # decide how many iterations to update your target image

for ii in range(1, steps+1):

    # get the features from your target image
    target_features = get_features(target, resnet)

    # calculate the content loss
    content_loss = torch.mean((target_features['conv4_2'] - content_features['conv4_2'])**2)

    # initialize the style loss to 0
    style_loss = 0

    # add to the style loss for each layer's gram matrix loss
    for layer in style_weights:
        # get the "target" style representation for the layer
        target_feature = target_features[layer]
        target_gram = gram_matrix(target_feature)
        _, d, h, w = target_feature.shape
        # get the "style" style representation
        style_gram = style_grams[layer]
        # calculate the style loss for one layer, weighted appropriately
        layer_style_loss = style_weights[layer] * torch.mean((target_gram - style_gram)**2)
        # add to the style loss
        style_loss += layer_style_loss / (d * h * w)

    # calculate the *total* loss
    total_loss = content_weight * content_loss + style_weight * style_loss

    # update the target image
    optimizer.zero_grad()
    total_loss.backward()
    optimizer.step()

    # display intermediate images and print the loss
    if  ii % show_every == 0:
        print('Total loss: ', total_loss.item())
        plt.imshow(im_convert(target))
        plt.show()

# display content and final, target image
fig, (ax1, ax2,ax3) = plt.subplots(1, 3, figsize=(20, 10))
ax1.imshow(im_convert(content))
ax2.imshow(im_convert(style))
ax3.imshow(im_convert(target))